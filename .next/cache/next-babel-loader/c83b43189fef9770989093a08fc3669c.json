{"ast":null,"code":"const request = require('request-promise');\n\nconst cookie = require('cookie');\n\nconst cookieOptions = require('../../_util/cookie/options');\n\nconst jwt = require('jsonwebtoken');\n\nconst {\n  encrypt\n} = require('../../_util/token/encryption');\n\nmodule.exports = async (req, res) => {\n  //  confirm state match to mitigate CSRF\n  if (req.query.state === req.cookies.state) {\n    // prepare options for token exchange\n    const options = {\n      method: 'POST',\n      url: `https://${process.env.AUTH0_DOMAIN}/oauth/token`,\n      headers: {\n        'content-type': 'application/x-www-form-urlencoded'\n      },\n      form: {\n        grant_type: 'authorization_code',\n        client_id: process.env.AUTH0_CLIENT_ID,\n        client_secret: process.env.AUTH0_CLIENT_SECRET,\n        code: req.query.code,\n        redirect_uri: `${process.env.AUTH0_REDIRECT_URI}/api/auth/callback/`\n      },\n      json: true\n    }; // send request for token exchange\n\n    const auth = await request(options); // check no error on token exchange\n\n    if (!auth.error) {\n      res.setHeader('Location', '/'); //  confirm nonce match to mitigate token replay attack\n\n      if (req.cookies.nonce === jwt.decode(auth.id_token).nonce) {\n        // encrypt access token\n        const accessEncrypted = encrypt(auth.access_token); // add id_token (browser) and access_token (httpOnly + encrypted) as cookies\n\n        res.setHeader('Set-Cookie', [cookie.serialize('id_token', String(auth.id_token), cookieOptions(false, true)), cookie.serialize('access_token', String(accessEncrypted), cookieOptions(true, true))]); // send response\n\n        res.status(302).end();\n      } else {\n        // advise token replay attack possible if nonce's do not match\n        res.send('Nonce mismatch, potential token replay attack underway.');\n      }\n    }\n  } else {\n    // advise CSRF attack likely if states do not match\n    res.send('State mismatch, CSRF attack likely.');\n  }\n};","map":{"version":3,"sources":["/Users/mcs/Development/projects/sandbox/tweet-review/pages/api/auth/callback/index.js"],"names":["request","require","cookie","cookieOptions","jwt","encrypt","module","exports","req","res","query","state","cookies","options","method","url","process","env","AUTH0_DOMAIN","headers","form","grant_type","client_id","AUTH0_CLIENT_ID","client_secret","AUTH0_CLIENT_SECRET","code","redirect_uri","AUTH0_REDIRECT_URI","json","auth","error","setHeader","nonce","decode","id_token","accessEncrypted","access_token","serialize","String","status","end","send"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,4BAAD,CAA7B;;AACA,MAAMG,GAAG,GAAGH,OAAO,CAAC,cAAD,CAAnB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAcJ,OAAO,CAAC,8BAAD,CAA3B;;AAEAK,MAAM,CAACC,OAAP,GAAiB,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AACnC;AACA,MAAID,GAAG,CAACE,KAAJ,CAAUC,KAAV,KAAoBH,GAAG,CAACI,OAAJ,CAAYD,KAApC,EAA2C;AACzC;AACA,UAAME,OAAO,GAAG;AACdC,MAAAA,MAAM,EAAE,MADM;AAEdC,MAAAA,GAAG,EAAG,WAAUC,OAAO,CAACC,GAAR,CAAYC,YAAa,cAF3B;AAGdC,MAAAA,OAAO,EAAE;AAAE,wBAAgB;AAAlB,OAHK;AAIdC,MAAAA,IAAI,EAAE;AACJC,QAAAA,UAAU,EAAE,oBADR;AAEJC,QAAAA,SAAS,EAAEN,OAAO,CAACC,GAAR,CAAYM,eAFnB;AAGJC,QAAAA,aAAa,EAAER,OAAO,CAACC,GAAR,CAAYQ,mBAHvB;AAIJC,QAAAA,IAAI,EAAElB,GAAG,CAACE,KAAJ,CAAUgB,IAJZ;AAKJC,QAAAA,YAAY,EAAG,GAAEX,OAAO,CAACC,GAAR,CAAYW,kBAAmB;AAL5C,OAJQ;AAWdC,MAAAA,IAAI,EAAE;AAXQ,KAAhB,CAFyC,CAezC;;AACA,UAAMC,IAAI,GAAG,MAAM9B,OAAO,CAACa,OAAD,CAA1B,CAhByC,CAiBzC;;AACA,QAAI,CAACiB,IAAI,CAACC,KAAV,EAAiB;AACftB,MAAAA,GAAG,CAACuB,SAAJ,CAAc,UAAd,EAA0B,GAA1B,EADe,CAEf;;AACA,UAAIxB,GAAG,CAACI,OAAJ,CAAYqB,KAAZ,KAAsB7B,GAAG,CAAC8B,MAAJ,CAAWJ,IAAI,CAACK,QAAhB,EAA0BF,KAApD,EAA2D;AACzD;AACA,cAAMG,eAAe,GAAG/B,OAAO,CAACyB,IAAI,CAACO,YAAN,CAA/B,CAFyD,CAGzD;;AACA5B,QAAAA,GAAG,CAACuB,SAAJ,CAAc,YAAd,EAA4B,CAC1B9B,MAAM,CAACoC,SAAP,CACE,UADF,EAEEC,MAAM,CAACT,IAAI,CAACK,QAAN,CAFR,EAGEhC,aAAa,CAAC,KAAD,EAAQ,IAAR,CAHf,CAD0B,EAM1BD,MAAM,CAACoC,SAAP,CACE,cADF,EAEEC,MAAM,CAACH,eAAD,CAFR,EAGEjC,aAAa,CAAC,IAAD,EAAO,IAAP,CAHf,CAN0B,CAA5B,EAJyD,CAgBzD;;AACAM,QAAAA,GAAG,CAAC+B,MAAJ,CAAW,GAAX,EAAgBC,GAAhB;AACD,OAlBD,MAkBO;AACL;AACAhC,QAAAA,GAAG,CAACiC,IAAJ,CAAS,yDAAT;AACD;AACF;AACF,GA5CD,MA4CO;AACL;AACAjC,IAAAA,GAAG,CAACiC,IAAJ,CAAS,qCAAT;AACD;AACF,CAlDD","sourcesContent":["const request = require('request-promise');\nconst cookie = require('cookie');\nconst cookieOptions = require('../../_util/cookie/options');\nconst jwt = require('jsonwebtoken');\nconst { encrypt } = require('../../_util/token/encryption');\n\nmodule.exports = async (req, res) => {\n  //  confirm state match to mitigate CSRF\n  if (req.query.state === req.cookies.state) {\n    // prepare options for token exchange\n    const options = {\n      method: 'POST',\n      url: `https://${process.env.AUTH0_DOMAIN}/oauth/token`,\n      headers: { 'content-type': 'application/x-www-form-urlencoded' },\n      form: {\n        grant_type: 'authorization_code',\n        client_id: process.env.AUTH0_CLIENT_ID,\n        client_secret: process.env.AUTH0_CLIENT_SECRET,\n        code: req.query.code,\n        redirect_uri: `${process.env.AUTH0_REDIRECT_URI}/api/auth/callback/`\n      },\n      json: true\n    };\n    // send request for token exchange\n    const auth = await request(options);\n    // check no error on token exchange\n    if (!auth.error) {\n      res.setHeader('Location', '/');\n      //  confirm nonce match to mitigate token replay attack\n      if (req.cookies.nonce === jwt.decode(auth.id_token).nonce) {\n        // encrypt access token\n        const accessEncrypted = encrypt(auth.access_token);\n        // add id_token (browser) and access_token (httpOnly + encrypted) as cookies\n        res.setHeader('Set-Cookie', [\n          cookie.serialize(\n            'id_token',\n            String(auth.id_token),\n            cookieOptions(false, true)\n          ),\n          cookie.serialize(\n            'access_token',\n            String(accessEncrypted),\n            cookieOptions(true, true)\n          )\n        ]);\n        // send response\n        res.status(302).end();\n      } else {\n        // advise token replay attack possible if nonce's do not match\n        res.send('Nonce mismatch, potential token replay attack underway.');\n      }\n    }\n  } else {\n    // advise CSRF attack likely if states do not match\n    res.send('State mismatch, CSRF attack likely.');\n  }\n};\n"]},"metadata":{},"sourceType":"script"}